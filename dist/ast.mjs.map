{"version":3,"sources":["../lib/components/Module.ts","../lib/components/Program.ts","../lib/nodes/node.ts","../lib/nodes/level-4/CommonNodes/IdentNode.ts","../lib/nodes/level-3/StmtNodes/BlockStmtNode.ts","../lib/nodes/level-3/StmtNodes/LetStmtNode.ts","../lib/nodes/level-3/StmtNodes/FuncStmtNode.ts","../lib/nodes/level-3/StmtNodes/UseStmtNode.ts","../lib/nodes/level-3/StmtNodes/DefStmtNode.ts","../lib/nodes/level-3/StmtNodes/LoopStmtNode.ts","../lib/nodes/level-3/StmtNodes/ControlFlowStmtNode.ts","../lib/nodes/level-3/StmtNodes/TestStmtNode.ts","../lib/nodes/level-1/StmtNode.ts","../lib/nodes/level-4/ExprNodes/LiteralNode.ts","../lib/nodes/level-4/ExprNodes/ObjectNode.ts","../lib/nodes/level-4/ExprNodes/ParenNode.ts","../lib/nodes/level-3/TypeNodes/PrimitiveTypeNode.ts","../lib/nodes/level-3/TypeNodes/OptionalTypeNode.ts","../lib/nodes/level-3/TypeNodes/PointerTypeNode.ts","../lib/nodes/level-3/TypeNodes/ArrayTypeNode.ts","../lib/nodes/level-3/TypeNodes/TupleTypeNode.ts","../lib/nodes/level-3/TypeNodes/FunctionTypeNode.ts","../lib/nodes/level-3/TypeNodes/StructTypeNode.ts","../lib/nodes/level-3/TypeNodes/EnumTypeNode.ts","../lib/nodes/level-3/TypeNodes/UnionTypeNode.ts","../lib/nodes/level-3/TypeNodes/ErrsetTypeNode.ts","../lib/nodes/level-3/TypeNodes/ParenTypeNode.ts","../lib/nodes/level-2/TypeNode.ts","../lib/nodes/level-3/ExprNodes/PrimaryNode.ts","../lib/nodes/level-5/ExprNodes/MemberAccessNode.ts","../lib/nodes/level-5/ExprNodes/ArrayAccessNode.ts","../lib/nodes/level-5/ExprNodes/CallNode.ts","../lib/nodes/level-3/ExprNodes/PostfixNode.ts","../lib/nodes/level-3/ExprNodes/PrefixNode.ts","../lib/nodes/level-3/ExprNodes/BinaryNode.ts","../lib/nodes/level-3/ExprNodes/ConditionalNode.ts","../lib/nodes/level-3/ExprNodes/IfNode.ts","../lib/nodes/level-3/ExprNodes/SwitchNode.ts","../lib/nodes/level-3/ExprNodes/CatchNode.ts","../lib/nodes/level-3/ExprNodes/TryNode.ts","../lib/nodes/level-3/ExprNodes/RangeNode.ts","../lib/nodes/level-3/ExprNodes/OrelseNode.ts","../lib/nodes/level-3/ExprNodes/AsNode.ts","../lib/nodes/level-5/ExprNodes/PropNode.ts","../lib/nodes/level-5/ExprNodes/CaseNode.ts","../lib/nodes/level-5/ExprNodes/DefaultNode.ts","../lib/nodes/level-3/ExprNodes/TypeofNode.ts","../lib/nodes/level-3/ExprNodes/SizeofNode.ts","../lib/nodes/level-2/ExprNode.ts","../lib/nodes/level-4/ExprNodes/ExprTupleNode.ts","../lib/nodes/level-5/ExprNodes/EnumVariantNode.ts","../lib/nodes/level-5/common/FieldNode.ts","../lib/nodes/level-5/ExprNodes/StructMemberNode.ts"],"sourcesContent":["// Module.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { StmtNode, StmtKind }   from '../nodes/level-1/StmtNode';\n    import { FuncStmtNode }             from '../nodes/level-3/StmtNodes/FuncStmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Module {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            constructor(\n                public name         : string,\n                public statements   : StmtNode[],\n                public exports      : string[],\n                public imports      : string[],\n                public metadata     : Record<string, unknown>,\n            ) { }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(name: string, stmts?: StmtNode[], metadata?: Record<string, unknown>): Module {\n                return new Module(name, stmts || [], [], [], metadata || {});\n            }\n\n            validate(): boolean {\n                try {\n                    // Validate module name\n                    if (!this.name.trim()) {return false;}\n\n                    // Validate all statements\n                    return this.statements.every(stmt => stmt.validate());\n                } catch {\n                    return false;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── FIND ──────────────────────────────┐\n\n            findStatements(predicate: (stmt: StmtNode) => boolean): StmtNode[] {\n                return this.statements.filter(predicate);\n            }\n\n            findStatement(predicate: (stmt: StmtNode) => boolean): StmtNode | undefined {\n                return this.statements.find(predicate);\n            }\n\n            findStatementsByKind(kind: StmtKind): StmtNode[] {\n                return this.statements.filter(stmt => stmt.kind === kind);\n            }\n\n            findFunction(name: string): FuncStmtNode | undefined {\n                for (const stmt of this.statements) {\n                    if (stmt.is('Func') && stmt.getFunc()!.ident.name === name) {\n                        return stmt.getFunc();\n                    }\n                }\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── CTRL ──────────────────────────────┐\n\n            removeStatement(index: number): Module {\n                if (index < 0 || index >= this.statements.length) {\n                    throw new Error(`Statement index ${index} out of bounds (0-${this.statements.length - 1})`);\n                }\n\n                const newStatements = [...this.statements];\n                newStatements.splice(index, 1);\n                return new Module(\n                    this.name,\n                    newStatements,\n                    [...this.exports],\n                    [...this.imports],\n                    { ...this.metadata }\n                );\n            }\n\n            insertStatement(index: number, statement: StmtNode): Module {\n                if (index < 0 || index > this.statements.length) {\n                    throw new Error(`Statement index ${index} out of bounds (0-${this.statements.length})`);\n                }\n\n                const newStatements = [...this.statements];\n                newStatements.splice(index, 0, statement);\n                return new Module(\n                    this.name,\n                    newStatements,\n                    [...this.exports],\n                    [...this.imports],\n                    { ...this.metadata }\n                );\n            }\n\n            replaceStatement(index: number, statement: StmtNode): Module {\n                if (index < 0 || index >= this.statements.length) {\n                    throw new Error(`Statement index ${index} out of bounds (0-${this.statements.length - 1})`);\n                }\n\n                const newStatements = [...this.statements];\n                newStatements[index] = statement;\n                return new Module(\n                    this.name,\n                    newStatements,\n                    [...this.exports],\n                    [...this.imports],\n                    { ...this.metadata }\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            isEmpty(): boolean {\n                return this.statements.length === 0;\n            }\n\n            hasStatement(statement: StmtNode): boolean {\n                return this.statements.includes(statement);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            getStatementCount(): number {\n                return this.statements.length;\n            }\n\n            getTotalNodes(): number {\n                let count = 1; // Count self\n                for (const statement of this.statements) {\n                    const countt = 0;\n                    statement.traverse(() => void (count++));\n                    count += countt;\n                }\n                return count;\n            }\n\n            getStatementAt(index: number): StmtNode | undefined {\n                if (index < 0 || index >= this.statements.length) {\n                    return undefined;\n                }\n                return this.statements[index];\n            }\n\n            getStatementIndex(statement: StmtNode): number {\n                return this.statements.indexOf(statement);\n            }\n\n            getPublicStatements(): StmtNode[] {\n                const arr : StmtNode[] = [];\n\n                for (const stmt of this.statements) {\n                    if(\n                        (stmt.is('Let')     && stmt.getLet()!.field.visibility.kind !== 'Private') ||\n                        (stmt.is('Def')     && stmt.getDef()!.visibility.kind  !== 'Private') ||\n                        (stmt.is('Func')    && stmt.getFunc()!.visibility.kind !== 'Private')\n                    ) { arr.push(stmt); }\n                }\n\n                return arr;\n            }\n\n            getPath(): string {\n                return this.metadata?.path as string || '';\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// Program.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Module }               from './Module';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Program {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            constructor(\n                public modules      : Map<string, Module>,\n                public metadata?    : Record<string, unknown>,\n            ) { }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(modules?: Module[], metadata?: Record<string, unknown>): Program {\n                // create module map from modules\n                const modulesMap = new Map<string, Module>();\n                for (const module of modules || []) {\n                    modulesMap.set(module.name, module);\n                }\n\n                return new Program(modulesMap, metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── FIND ──────────────────────────────┐\n\n            findModules(predicate: (module: Module, name: string) => boolean): [string, Module][] {\n                const results: [string, Module][] = [];\n                for (const [name, module] of this.modules) {\n                    if (predicate(module, name)) {\n                        results.push([name, module]);\n                    }\n                }\n                return results;\n            }\n\n            findModule(predicate: (module: Module, name: string) => boolean): [string, Module] | undefined {\n                for (const [name, module] of this.modules) {\n                    if (predicate(module, name)) {\n                        return [name, module];\n                    }\n                }\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── CTRL ──────────────────────────────┐\n\n            removeModule(name: string): Program {\n                if (!this.modules.has(name)) {return this;}\n\n                const newModules = new Map(this.modules);\n                newModules.delete(name);\n                return new Program(newModules, this.metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            isEmpty(): boolean {\n                return this.modules.size === 0 ||\n                    Array.from(this.modules.values()).every(m => m.statements.length === 0);\n            }\n\n            hasModule(name: string): boolean {\n                return this.modules.has(name);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            getModule(name: string): Module | undefined {\n                return this.modules.get(name);\n            }\n\n            getModuleNames(): string[] {\n                return Array.from(this.modules.keys());\n            }\n\n            getTotalModules(): number {\n                return this.modules.size;\n            }\n\n            getTotalStatements(): number {\n                return Array.from(this.modules.values())\n                    .reduce((total, module) => total + module.statements.length, 0);\n            }\n\n            getTotalNodes(): number {\n                let count = this.modules.size; // Count modules themselves\n                for (const module of this.modules.values()) {\n                    count += module.getTotalNodes();\n                }\n                return count;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export interface Span {\n        start           : number;\n        end             : number;\n    }\n\n    export type VisibilityKind = 'Unset' | 'Private' | 'Public' | 'Static';\n    export interface VisibilityInfo {\n        kind            : VisibilityKind;\n        span?           : Span;\n    }\n\n    export type MutabilityKind = 'Unset' | 'Mutable' | 'Immutable';\n    export interface MutabilityInfo {\n        kind            : MutabilityKind;\n        span?           : Span;\n    }\n\n    export type ComptimeKind = 'Unset' | 'Comptime' | 'Runtime';\n    export interface ComptimeInfo {\n        kind            : ComptimeKind;\n        span?           : Span;\n    }\n\n    export interface NameInfo {\n        name            : string;\n        span            : Span;\n    }\n\n    export const DEF_SPAN : Span = { start: -1, end: -1 };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export abstract class Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            abstract readonly level     : number;\n            abstract readonly kind      : string;\n            abstract readonly span      : Span;\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── FIND ──────────────────────────────┐\n\n            // Find descendants matching predicate with proper type guard support\n            findAll<U extends Node>(predicate: (node: Node) => node is U): U[];\n            findAll(predicate: (node: Node) => boolean): Node[];\n            findAll(predicate: (node: Node) => boolean): Node[] {\n                const results: Node[] = [];\n                this.traverse(node => {\n                    if (predicate(node)) {results.push(node);}\n                });\n                return results;\n            }\n\n            // Find first descendant matching predicate with proper type guard support\n            find<U extends Node>(predicate: (node: Node) => node is U): U | null;\n            find(predicate: (node: Node) => boolean): Node | null;\n            find(predicate: (node: Node) => boolean): Node | null {\n                let result: Node | null = null;\n                this.traverse(node => {\n                    if (!result && predicate(node)) {\n                        result = node;\n                        return 'stop';\n                    }\n                });\n                return result;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────────── TRAVERSE ────────────────────────────┐\n\n            // Depth-first traversal with early termination support and enhanced error handling\n            traverse(visitor: (node: Node) => void | 'stop'): void {\n                try {\n                    const result = visitor(this);\n                    if (result === 'stop') {return;}\n\n                    // Get children with proper error handling\n                    let children: readonly Node[];\n                    try {\n                        children = this.getChildrenNodes();\n                    } catch (error) {\n                        throw new Error(`Failed to get children from ${this.kind} node: ${error}`);\n                    }\n\n                    // Validate children array\n                    if (!Array.isArray(children)) {\n                        throw new Error(`getChildrenNodes() returned non-array from ${this.kind} node: ${typeof children}`);\n                    }\n\n                    // Traverse each child with individual error handling\n                    for (let i = 0; i < children.length; i++) {\n                        const child = children[i];\n\n                        // Validate child\n                        if (!child) {\n                            console.warn(`Child ${i} is null/undefined in ${this.kind} node`);\n                            continue;\n                        }\n\n                        if (typeof child !== 'object') {\n                            console.warn(`Child ${i} is not an object in ${this.kind} node: ${typeof child}`);\n                            continue;\n                        }\n\n                        // Check if child is a proper Node\n                        if (!('traverse' in child) || typeof child.traverse !== 'function') {\n                            console.error(`Child ${i} (${child.constructor?.name || 'unknown'}) of ${this.kind} node is missing traverse method`);\n                            console.error('Child object keys:', Object.keys(child));\n                            console.error('Child prototype:', Object.getPrototypeOf(child));\n                            throw new Error(`Child node ${child.constructor?.name || 'unknown'} missing traverse method`);\n                        }\n\n                        // Check if child is actually a Node instance\n                        if (!(child instanceof Node)) {\n                            console.error(`Child ${i} of ${this.kind} node is not a Node instance:`, child.constructor?.name);\n                            throw new Error(`Child ${child.constructor?.name || 'unknown'} is not a Node instance`);\n                        }\n\n                        try {\n                            child.traverse(visitor);\n                        } catch (error) {\n                            throw new Error(`Traversal failed at child ${i} (${child.constructor?.name || 'unknown'}) of ${this.kind} node: ${error}`);\n                        }\n                    }\n                } catch (error) {\n                    // Re-throw with context for better debugging\n                    if (error instanceof Error && error.message.includes('Traversal failed')) {\n                        throw error; // Already has context\n                    }\n                    throw new Error(`Traversal failed at ${this.kind} node: ${error}`);\n                }\n            }\n\n            // Pre-order traversal (visit parent before children)\n            traversePreOrder(visitor: (node: Node) => void | 'stop'): void {\n                this.traverse(visitor);\n            }\n\n            // Post-order traversal (visit children before parent)\n            traversePostOrder(visitor: (node: Node) => void | 'stop'): void {\n                const visitPostOrder = (node: Node): void | 'stop' => {\n                    // First traverse children\n                    for (const child of node.getChildrenNodes()) {\n                        const result = visitPostOrder(child);\n                        if (result === 'stop') {return 'stop';}\n                    }\n\n                    // Then visit current node\n                    return visitor(node);\n                };\n\n                visitPostOrder(this);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            // Check if this node has any children\n            hasChildren(): boolean {\n                try {\n                    return this.getChildrenNodes().length > 0;\n                } catch {\n                    return false;\n                }\n            }\n\n            // Check if this node is a leaf (no children)\n            isLeaf(): boolean {\n                return !this.hasChildren();\n            }\n\n            // Get the depth of this node (maximum distance to any leaf)\n            getDepth(): number {\n                if (this.isLeaf()) {return 0;}\n\n                let maxDepth = 0;\n                try {\n                    for (const child of this.getChildrenNodes()) {\n                        maxDepth = Math.max(maxDepth, child.getDepth());\n                    }\n                } catch (error) {\n                    console.warn(`Error getting depth for ${this.kind} node:`, error);\n                    return 0;\n                }\n\n                return maxDepth + 1;\n            }\n\n            // Count total number of descendant nodes (including self)\n            getNodeCount(): number {\n                let count = 1; // Count self\n                try {\n                    this.traverse(node => {\n                        if (node !== this) {count++;}\n                    });\n                } catch (error) {\n                    console.warn(`Error counting nodes for ${this.kind} node:`, error);\n                }\n                return count;\n            }\n\n            // Get all ancestor kind's in the tree\n            getNodeKinds(): Set<string> {\n                const types = new Set<string>();\n                try {\n                    this.traverse(node => {\n                        types.add(node.kind);\n                    });\n                } catch (error) {\n                    console.warn(`Error getting node types for ${this.kind} node:`, error);\n                    types.add(this.kind); // At least add this node's type\n                }\n                return types;\n            }\n\n            // Create a deep clone of the entire subtree\n            deepClone(newSpan?: Span): Node {\n                // This is a default implementation that subclasses can override for optimization\n                const cloned = this.clone(newSpan);\n\n                // Note: Subclasses should override this method to handle their specific child cloning\n                // This is a fallback that just returns a shallow clone\n                return cloned;\n            }\n\n            // Validation method that subclasses can override\n            validate(): boolean {\n                try {\n                    // Basic validation: ensure all children are valid\n                    const children = this.getChildrenNodes();\n                    for (const child of children) {\n                        if (!child || !child.validate()) {\n                            return false;\n                        }\n                    }\n                    return true;\n                } catch (error) {\n                    console.warn(`Validation error for ${this.kind} node:`, error);\n                    return false;\n                }\n            }\n\n            // Pretty print the AST structure with better error handling\n            printTree(indent = 0): string {\n                const spaces = '  '.repeat(indent);\n                const nodeInfo = `${spaces}${this.kind} (${this.span.start}-${this.span.end})`;\n\n                try {\n                    if (this.isLeaf()) {\n                        return nodeInfo;\n                    }\n\n                    const children = this.getChildrenNodes()\n                        .map(child => {\n                            try {\n                                return child.printTree(indent + 1);\n                            } catch (error) {\n                                return `${spaces}  ERROR: ${child?.constructor?.name || 'unknown'} - ${error}`;\n                            }\n                        })\n                        .join('\\n');\n\n                    return `${nodeInfo}\\n${children}`;\n                } catch (error) {\n                    return `${nodeInfo} [ERROR: ${error}]`;\n                }\n            }\n\n            // Check structural equality with another node (ignoring spans)\n            structurallyEquals(other: Node): boolean {\n                if (this.kind !== other.kind) {return false;}\n\n                try {\n                    const thisChildren = this.getChildrenNodes();\n                    const otherChildren = other.getChildrenNodes();\n\n                    if (thisChildren.length !== otherChildren.length) {return false;}\n\n                    return thisChildren.every((child, index) =>\n                        child.structurallyEquals(otherChildren[index])\n                    );\n                } catch {\n                    return false;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────────── ABSTRACT ────────────────────────────┐\n\n            // Get direct children (must be implemented by subclasses)\n            abstract getChildrenNodes(): Node[];\n\n            // Clone node (shallow copy with new span)\n            abstract clone(newSpan?: Span): Node;\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class IdentNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Ident' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public name         : string,\n                public builtin      : boolean,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n                return children;\n            }\n\n            clone(newSpan?: Span): IdentNode {\n                const cloned = new IdentNode(newSpan ?? this.span, this.name, this.builtin);\n                return cloned;\n            }\n\n            validate(): boolean {\n                return this.name.trim().length > 0;\n            }\n\n            toString(): string {\n                return `${this.builtin ? '@' : ''}${this.name}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, name: string, builtin = false): IdentNode {\n                return new IdentNode(span, name, builtin);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// BlockStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { StmtNode }     from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class BlockStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Block' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public stmts        : StmtNode[],\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.stmts ? this.stmts : [];\n            }\n\n            clone(newSpan?: Span): BlockStmtNode {\n                return new BlockStmtNode(\n                    newSpan ?? this.span,\n                    this.stmts\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, stmts?: StmtNode[]): BlockStmtNode {\n                return new BlockStmtNode(span, stmts ?? []);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// LetStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo, MutabilityInfo, ComptimeInfo } from '../../node';\n    import { ExprNode }                 from '../../level-2/ExprNode';\n    import { TypeNode }                 from '../../level-2/TypeNode';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n    import { FieldNode }                from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class LetStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Let' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public field            : FieldNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.field.getChildrenNodes();\n            }\n\n            clone(newSpan?: Span): LetStmtNode {\n                return new LetStmtNode(\n                    newSpan ?? this.span,\n                    this.field.clone(newSpan),\n                );\n            }\n\n            // for factory\n            getField(): FieldNode {\n                return this.field;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, mutability: MutabilityInfo, ident: IdentNode, type?: TypeNode, initializer?: ExprNode): LetStmtNode {\n                const field = FieldNode.create(span, visibility, comptime, mutability, ident, type, initializer);\n                return new LetStmtNode(span, field);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// FuncStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo, ComptimeInfo } from '../../node';\n    import { TypeNode }                 from '../../level-2/TypeNode';\n    import { FieldNode }                from '../../level-5/common/FieldNode';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n    import { StmtNode }                 from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class FuncStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Function' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public comptime         : ComptimeInfo,\n                public isInline         : boolean,\n                public ident            : IdentNode,\n                public parameters       : FieldNode[],\n                public body             : StmtNode,\n                public errorType?       : TypeNode,\n                public returnType?      : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                // Add parameters\n                for (const param of this.parameters) {\n                    children.push(param);\n                }\n\n                if (this.errorType) {children.push(this.errorType);}\n                if (this.returnType) {children.push(this.returnType);}\n                if (this.body) {children.push(this.body);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): FuncStmtNode {\n                return new FuncStmtNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.comptime,\n                    this.isInline,\n                    this.ident,\n                    this.parameters,\n                    this.body,\n                    this.errorType,\n                    this.returnType,\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, isInline: boolean, ident: IdentNode, parameters: FieldNode[], body: StmtNode, errorType?: TypeNode, returnType?: TypeNode): FuncStmtNode {\n                return new FuncStmtNode(span, visibility, comptime, isInline, ident, parameters, body, errorType, returnType);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// UseStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo } from '../../node';\n    import { IdentNode } from '../../level-4/CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class UseStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Use' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public targetArr        : IdentNode[] | undefined,\n                public alias?           : IdentNode,\n                public path?            : string,\n                public pathSpan?        : Span,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return []; // No child nodes for UseNode\n            }\n\n            clone(newSpan?: Span): UseStmtNode {\n                return new UseStmtNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.targetArr,\n                    this.alias,\n                    this.path,\n                    this.pathSpan\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, targetArr: IdentNode[] | undefined, alias?: IdentNode, path?: string, pathSpan?: Span): UseStmtNode {\n                return new UseStmtNode(span, visibility, targetArr, alias, path, pathSpan);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            isAllModule(): boolean {\n                return this.targetArr === undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// DefStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo } from '../../node';\n    import { TypeNode }         from '../../level-2/TypeNode';\n    import { IdentNode }        from '../../level-4/CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DefStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Def' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public ident            : IdentNode,\n                public type             : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.type];\n            }\n\n            clone(newSpan?: Span): DefStmtNode {\n                return new DefStmtNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.ident,\n                    this.type\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, ident: IdentNode, type: TypeNode): DefStmtNode {\n                return new DefStmtNode(span, visibility, ident, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// LoopStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { StmtNode }     from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type LoopKind = 'For' | 'While' | 'Do';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class LoopStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public span : Span,\n                public kind : LoopKind,\n                public expr : ExprNode,\n                public stmt : StmtNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.expr, this.stmt];\n            }\n\n            clone(newSpan?: Span): LoopStmtNode {\n                return new LoopStmtNode(\n                    newSpan ?? this.span,\n                    this.kind,\n                    this.expr,\n                    this.stmt\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            isFor(): boolean {\n                return this.kind === 'For';\n            }\n\n            isWhile(): boolean {\n                return this.kind === 'While';\n            }\n\n            isDo(): boolean {\n                return this.kind === 'While';\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static createFor(span: Span, expr: ExprNode, stmt: StmtNode): LoopStmtNode {\n                return new LoopStmtNode(span, 'For', expr, stmt);\n            }\n\n            static createWhile(span: Span, expr: ExprNode, stmt: StmtNode): LoopStmtNode {\n                return new LoopStmtNode(span, 'While', expr, stmt);\n            }\n\n            static createDo(span: Span, expr: ExprNode, stmt: StmtNode): LoopStmtNode {\n                return new LoopStmtNode(span, 'Do', expr, stmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ControlFlowStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type ControlFlowKind = 'return' | 'break' | 'continue' | 'defer' | 'throw';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ControlFlowStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public kind         : ControlFlowKind,\n                public value?       : ExprNode, // Only for Return\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.value ? [this.value] : [];\n            }\n\n            clone(newSpan?: Span): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(\n                    newSpan ?? this.span,\n                    this.kind,\n                    this.value\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            isReturn(): boolean {\n                return this.kind === 'return';\n            }\n\n            isDefer(): boolean {\n                return this.kind === 'defer';\n            }\n\n            isThrow(): boolean {\n                return this.kind === 'throw';\n            }\n\n            isBreak(): boolean {\n                return this.kind === 'break';\n            }\n\n            isContinue(): boolean {\n                return this.kind === 'continue';\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static asReturn(span: Span, value?: ExprNode): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'return', value);\n            }\n\n            static asDefer(span: Span, value?: ExprNode): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'defer', value);\n            }\n\n            static asThrow(span: Span, value?: ExprNode): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'throw', value);\n            }\n\n            static asBreak(span: Span): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'break');\n            }\n\n            static asContinue(span: Span): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'continue');\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// TestStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, NameInfo } from '../../node';\n    import { BlockStmtNode }        from './BlockStmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TestStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Test' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public name             : NameInfo | undefined,\n                public block            : BlockStmtNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.block];\n            }\n\n            clone(newSpan?: Span): TestStmtNode {\n                return new TestStmtNode(\n                    newSpan ?? this.span,\n                    this.name,\n                    this.block\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, name: NameInfo | undefined, block: BlockStmtNode): TestStmtNode {\n                return new TestStmtNode(span, name, block);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, MutabilityInfo, VisibilityInfo, ComptimeInfo, NameInfo }\n                                        from '../node';\n    import { ExprNode }                 from '../level-2/ExprNode';\n    import { BlockStmtNode }            from '../level-3/StmtNodes/BlockStmtNode';\n    import { LetStmtNode }              from '../level-3/StmtNodes/LetStmtNode';\n    import { FuncStmtNode }             from '../level-3/StmtNodes/FuncStmtNode';\n    import { UseStmtNode }              from '../level-3/StmtNodes/UseStmtNode';\n    import { DefStmtNode }              from '../level-3/StmtNodes/DefStmtNode';\n    import { LoopStmtNode }             from '../level-3/StmtNodes/LoopStmtNode';\n    import { ControlFlowStmtNode }      from '../level-3/StmtNodes/ControlFlowStmtNode';\n    import { TypeNode }                 from '../level-2/TypeNode';\n    import { FieldNode }                from '../level-5/common/FieldNode';\n    import { IdentNode }                from '../level-4/CommonNodes/IdentNode';\n    import { TestStmtNode }             from '../level-3/StmtNodes/TestStmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type StmtKind =\n    | 'Unset'       | 'Expression'  | 'Block'       | 'Use'         | 'Def'\n    | 'Let'         | 'Func'        | 'For'         | 'While'       | 'Return'\n    | 'Break'       | 'Continue'    | 'Defer'       | 'Throw'       | 'Do'\n    | 'Test';\n\n    export type StmtTypes =\n    | ExprNode      | BlockStmtNode | TestStmtNode  | LetStmtNode   | FuncStmtNode\n    | UseStmtNode   | DefStmtNode   | LoopStmtNode  | ControlFlowStmtNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class StmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 1;\n\n            constructor(\n                public kind         : StmtKind,\n                public span         : Span,\n                public source       : StmtTypes,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if (this.is('Block')) {\n                    children.push(...this.getBlock()!.getChildrenNodes());\n                } else if (this.source instanceof Node) {\n                    children.push(this.source);\n                }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): StmtNode {\n                return new StmtNode(this.kind, newSpan ?? this.span, this.source);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            getExpr(): ExprNode | undefined {\n                if (this.is('Expression')) {\n                    return this.source as ExprNode;\n                }\n                return undefined;\n            }\n\n            getBlock(): BlockStmtNode | undefined {\n                if (this.is('Block')) {\n                    return this.source as BlockStmtNode;\n                }\n                return undefined;\n            }\n\n            getTest(): TestStmtNode | undefined {\n                if (this.is('Test')) {\n                    return this.source as TestStmtNode;\n                }\n                return undefined;\n            }\n\n            getUse(): UseStmtNode | undefined {\n                if (this.is('Use')) {\n                    return this.source as UseStmtNode;\n                }\n                return undefined;\n            }\n\n            getDef(): DefStmtNode | undefined {\n                if (this.is('Def')) {\n                    return this.source as DefStmtNode;\n                }\n                return undefined;\n            }\n\n            getLet(): LetStmtNode | undefined {\n                if (this.is('Let')) {\n                    return this.source as LetStmtNode;\n                }\n                return undefined;\n            }\n\n            getFunc(): FuncStmtNode | undefined {\n                if (this.is('Func')) {\n                    return this.source as FuncStmtNode;\n                }\n                return undefined;\n            }\n\n            getLoop(): LoopStmtNode | undefined {\n                if (this.is('For') || this.is('While') || this.is('Do')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n            getFor(): LoopStmtNode | undefined {\n                if (this.is('For')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n            getWhile(): LoopStmtNode | undefined {\n                if (this.is('While')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n\n            getDo(): LoopStmtNode | undefined {\n                if (this.is('Do')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n            getCtrlflow(): ControlFlowStmtNode | undefined {\n                if (this.is('Return') || this.is('Defer') || this.is('Throw') || this.is('Break') || this.is('Continue')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getReturn(): ControlFlowStmtNode | undefined {\n                if (this.is('Return')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getDefer(): ControlFlowStmtNode | undefined {\n                if (this.is('Defer')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getThrow(): ControlFlowStmtNode | undefined {\n                if (this.is('Throw')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getBreak(): ControlFlowStmtNode | undefined {\n                if (this.is('Break')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getContinue(): ControlFlowStmtNode | undefined {\n                if (this.is('Continue')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getStmtName(): string | undefined {\n                if (this.is('Use')) {\n                    return (this.source as UseStmtNode).alias?.name ?? (this.source as UseStmtNode).path ?? 'unknown-use';\n                } else if (this.is('Def')) {\n                    return (this.source as DefStmtNode).ident.name;\n                } else if (this.is('Let')) {\n                    return (this.source as LetStmtNode).field.ident.name;\n                } else if (this.is('Func')) {\n                    return (this.source as FuncStmtNode).ident.name;\n                }\n                return undefined;\n            }\n\n            getStmtNameSpan(): Span | undefined {\n                if (this.is('Use')) {\n                    return (this.source as UseStmtNode).span;\n                } else if (this.is('Def')) {\n                    return (this.source as DefStmtNode).ident.span;\n                } else if (this.is('Let')) {\n                    return (this.source as LetStmtNode).field.ident.span;\n                } else if (this.is('Func')) {\n                    return (this.source as FuncStmtNode).ident.span;\n                }\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: StmtKind, span: Span, data: StmtTypes): StmtNode {\n                return new StmtNode(kind, span, data);\n            }\n\n            static asExpr(span: Span, expr: ExprNode): StmtNode {\n                return StmtNode.create('Expression', span, expr);\n            }\n\n            static asBlock(span: Span, stmts: StmtNode[]): StmtNode {\n                return StmtNode.create('Block', span, BlockStmtNode.create(span, stmts));\n            }\n\n            static asUse(span: Span, visibility: VisibilityInfo, targetArr: IdentNode[] | undefined, alias?: IdentNode, path?: string, pathSpan?: Span): StmtNode {\n                return StmtNode.create('Use', span, UseStmtNode.create(span, visibility, targetArr, alias, path, pathSpan));\n            }\n\n            static asDefine(span: Span, visibility: VisibilityInfo, ident: IdentNode, type: TypeNode): StmtNode {\n                return StmtNode.create('Def', span, DefStmtNode.create(span, visibility, ident, type));\n            }\n\n            static asLet(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, mutability: MutabilityInfo, ident: IdentNode, type?: TypeNode, initializer?: ExprNode): StmtNode {\n                return StmtNode.create('Let', span, LetStmtNode.create(span, visibility, comptime, mutability, ident, type, initializer));\n            }\n\n            static asFunc(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, isInline: boolean, ident: IdentNode, parameters: FieldNode[], errorType: TypeNode | undefined, returnType: TypeNode | undefined, body: StmtNode): StmtNode {\n                return StmtNode.create('Func', span, FuncStmtNode.create(span, visibility, comptime, isInline, ident, parameters, body, errorType, returnType));\n            }\n\n            static asFor(span: Span, expr: ExprNode, stmt: StmtNode): StmtNode {\n                return StmtNode.create('For', span, LoopStmtNode.createFor(span, expr, stmt));\n            }\n\n            static asWhile(span: Span, expr: ExprNode, stmt: StmtNode): StmtNode {\n                return StmtNode.create('While', span, LoopStmtNode.createWhile(span, expr, stmt));\n            }\n\n            static asDo(span: Span, expr: ExprNode, stmt: StmtNode): StmtNode {\n                return StmtNode.create('Do', span, LoopStmtNode.createDo(span, expr, stmt));\n            }\n\n            static asReturn(span: Span, value?: ExprNode): StmtNode {\n                return StmtNode.create('Return', span, ControlFlowStmtNode.asReturn(span, value));\n            }\n\n            static asDefer(span: Span, value?: ExprNode): StmtNode {\n                return StmtNode.create('Defer', span, ControlFlowStmtNode.asDefer(span, value));\n            }\n\n            static asThrow(span: Span, value?: ExprNode): StmtNode {\n                return StmtNode.create('Throw', span, ControlFlowStmtNode.asThrow(span, value));\n            }\n\n            static asBreak(span: Span): StmtNode {\n                return StmtNode.create('Break', span, ControlFlowStmtNode.asBreak(span));\n            }\n\n            static asContinue(span: Span): StmtNode {\n                return StmtNode.create('Continue', span, ControlFlowStmtNode.asContinue(span));\n            }\n\n            static asTest(span: Span, nameInfo: NameInfo | undefined, block: BlockStmtNode): StmtNode {\n                return StmtNode.create('Test', span, TestStmtNode.create(span, nameInfo, block));\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            is(kind: StmtKind): boolean {\n                return this.kind === kind;\n            }\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type LiteralKind =\n    | 'Unset'         | 'Array'           | 'String'        | 'Character'\n    | 'Integer'       | 'Float'           | 'Bool'          | 'Null'\n    | 'Undefined';\n\n    export type LiteralValue =\n    | number          | string            | boolean       | null\n    | undefined       | ExprNode[];\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class LiteralNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 4;\n\n            constructor(\n                public kind         : LiteralKind,\n                public span         : Span,\n                public value        : LiteralValue,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n                if (this.kind === 'Array' && Array.isArray(this.value)) {\n                    children.push(...(this.value as ExprNode[]));\n                }\n                return children;\n            }\n\n            clone(newSpan?: Span): LiteralNode {\n                const cloned = new LiteralNode(this.kind, newSpan ?? this.span, this.value);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HHLP ──────────────────────────────┐\n\n            is(kind: LiteralKind): boolean {\n                return this.kind === kind;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: LiteralKind, span: Span, value: LiteralValue): LiteralNode {\n                return new LiteralNode(kind, span, value);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { PropNode } from '../../level-5/ExprNodes/PropNode';\nimport { IdentNode } from '../CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ObjectNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Object' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public props        : PropNode[],\n                public ident        : IdentNode | undefined\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.props);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ObjectNode {\n                const cloned = new ObjectNode(newSpan || this.span, this.props, this.ident);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, props: PropNode[], ident: IdentNode | undefined): ObjectNode {\n                return new ObjectNode(span, props, ident);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ParenNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Paren' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public source       : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.source);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ParenNode {\n                const cloned = new ParenNode(newSpan || this.span, this.source);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, source: ExprNode): ParenNode {\n                return new ParenNode(span, source);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, DEF_SPAN }     from '../../node';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n    import { LiteralNode }              from '../../level-4/ExprNodes/LiteralNode';\n    import { ObjectNode }               from '../../level-4/ExprNodes/ObjectNode';\n    import { ParenNode }                from '../../level-4/ExprNodes/ParenNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PrimitiveKind =\n        | 'type'        | 'void'            | 'bool'        | 'signed'\n        | 'unsigned'    | 'float'           | 'und'         | 'null'\n        | 'cint'        | 'cflt'            | 'any'         | 'err';\n\n    export type PrimitiveTypes = IdentNode | LiteralNode | ParenNode | ObjectNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PrimitiveTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PrimitiveKind,\n                public span         : Span,\n                public text         ?: string,\n                public width        ?: number,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [];\n            }\n\n            clone(newSpan?: Span): PrimitiveTypeNode {\n                const cloned = new PrimitiveTypeNode(this.kind, newSpan || this.span, this.text, this.width);\n                return cloned;\n            }\n\n            toString(): string {\n                switch(this.kind) {\n                    case 'void':            return 'void';\n                    case 'type':            return 'type';\n                    case 'bool':            return 'bool';\n                    case 'signed':          return 'i'+this.width;\n                    case 'unsigned':        return 'u'+this.width;\n                    case 'float':           return 'f'+this.width;\n                    case 'und':             return 'undefined';\n                    case 'null':            return 'null';\n                    case 'cint':            return 'cint';\n                    case 'cflt':            return 'cflt';\n                    case 'any':             return 'any';\n                    case 'err':             return 'err';\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PrimitiveKind): boolean {\n                return this.kind === kind;\n            }\n\n            isVoid()          { return this.is('void'); }\n            isType()          { return this.is('type'); }\n            isNull()          { return this.is('null'); }\n            isUndefined()     { return this.is('und'); }\n            isBool()          { return this.is('bool'); }\n            isSigned()        { return this.is('signed'); }\n            isUnsigned()      { return this.is('unsigned'); }\n            isFloat()         { return this.is('float'); }\n            isInteger()       { return this.is('signed') || this.is('unsigned') || this.is('cint'); }\n            isComptimeInt()   { return this.is('cint'); }\n            isComptimeFloat() { return this.is('cflt'); }\n            isNumeric()       { return this.is('signed') || this.is('unsigned') || this.is('float') || this.is('cint') || this.is('cflt'); }\n            isAny()           { return this.is('any'); }\n            isErr()           { return this.is('err'); }\n\n            static calcWidth(prefix: string, text: string): number {\n                // Check if text starts with the prefix\n                if (!text.startsWith(prefix)) {return 0;}\n\n                // Extract the numeric part after the prefix\n                const numericPart = text.slice(prefix.length);\n\n                // Convert to number\n                const width = parseInt(numericPart, 10);\n\n                // Check if the conversion was successful\n                if (isNaN(width)) {return 0;}\n\n                return width;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PrimitiveKind, span: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return new PrimitiveTypeNode(kind, span, text, width);\n            }\n\n            static asVoid(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('void', span || DEF_SPAN);\n            }\n\n            static asType(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('type', span || DEF_SPAN);\n            }\n\n            static asNull(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('null', span || DEF_SPAN);\n            }\n\n            static asUndefined(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('und', span || DEF_SPAN);\n            }\n\n            static asAny(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('any', span || DEF_SPAN);\n            }\n\n            static asErr(span?: Span, text?: string): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('err', span || DEF_SPAN, text);\n            }\n\n            static asBool(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('bool', span || DEF_SPAN);\n            }\n\n            static asSigned(span?: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('signed', span || DEF_SPAN, text, width);\n            }\n\n            static asUnsigned(span?: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('unsigned', span || DEF_SPAN, text, width);\n            }\n\n            static asFloat(span?: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('float', span || DEF_SPAN, text, width);\n            }\n\n            static asComptimeInt(span?: Span, text?: string): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('cint', span || DEF_SPAN, text, 64);\n            }\n\n            static asComptimeFloat(span?: Span, text?: string): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('cflt', span || DEF_SPAN, text, 64);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class OptionalTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Optional' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public target       : TypeNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.target];\n            }\n\n            clone(newSpan?: Span): OptionalTypeNode {\n                const cloned = new OptionalTypeNode(newSpan || this.span, this.target);\n                return cloned;\n            }\n\n            toString(): string {\n                return `?${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, target: TypeNode): OptionalTypeNode {\n                return new OptionalTypeNode(span, target);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PointerTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Pointer' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public target       : TypeNode,\n                public mutable      : boolean\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.target];\n            }\n\n            clone(newSpan?: Span): PointerTypeNode {\n                const cloned = new PointerTypeNode(newSpan || this.span, this.target, this.mutable);\n                return cloned;\n            }\n\n            toString(): string {\n                return `*${this.mutable ? 'mut ' : ''}${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, target: TypeNode, mutable = false): PointerTypeNode {\n                return new PointerTypeNode(span, target, mutable);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n    import { ExprNode }     from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ArrayTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Array' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public target       : TypeNode,\n                public size         : ExprNode | undefined,\n                public mutable      : boolean\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.target);\n                if (this.size) {children.push(this.size);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ArrayTypeNode {\n                const cloned = new ArrayTypeNode(newSpan || this.span, this.target, this.size, this.mutable);\n                return cloned;\n            }\n\n            toString(): string {\n                return `[]${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            isU8Array(): boolean {\n                return (this.target.getPrimitive() && this.target.getPrimitive()!.kind === 'unsigned' && this.target.getPrimitive()!.width === 8) ?? false;\n            }\n\n            isU16Array(): boolean {\n                return (this.target.getPrimitive() && this.target.getPrimitive()!.kind === 'unsigned' && this.target.getPrimitive()!.width === 16) ?? false;\n            }\n\n            isU32Array(): boolean {\n                return (this.target.getPrimitive() && this.target.getPrimitive()!.kind === 'unsigned' && this.target.getPrimitive()!.width === 32) ?? false;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, target: TypeNode, size?: ExprNode, mutable = false): ArrayTypeNode {\n                return new ArrayTypeNode(span, target, size, mutable);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TupleTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Tuple' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public fields       : TypeNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [...this.fields];\n            }\n\n            clone(newSpan?: Span): TupleTypeNode {\n                const cloned = new TupleTypeNode(newSpan || this.span, this.fields);\n                return cloned;\n            }\n\n            toString(): string {\n                return `(${this.fields.join(', ')})`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, fields: TypeNode[]): TupleTypeNode {\n                return new TupleTypeNode(span, fields);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class FunctionTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Function' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public params       : TypeNode[],\n                public returnType   : TypeNode | undefined,\n                public errorType    : TypeNode | undefined,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.params);\n                if (this.returnType) {children.push(this.returnType);}\n                if (this.errorType) {children.push(this.errorType);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): FunctionTypeNode {\n                const cloned = new FunctionTypeNode(newSpan || this.span, this.params, this.returnType, this.errorType);\n                return cloned;\n            }\n\n            toString(): string {\n                return `function`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, params: TypeNode[], returnType?: TypeNode, errorType?: TypeNode): FunctionTypeNode {\n                return new FunctionTypeNode(span, params, returnType, errorType);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }       from '../../node';\n    import { StructMemberNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class StructTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Struct' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public members      : StructMemberNode[],\n                public name         : string = 'Anonymous',\n                public metadata     : Record<string, unknown>,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.members);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): StructTypeNode {\n                const cloned = new StructTypeNode(newSpan || this.span, this.members, this.name, this.metadata);\n                return cloned;\n            }\n\n            toString(): string {\n                return `struct`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, members: StructMemberNode[], name: string = 'Anonymous', metadata: Record<string, unknown> = {}): StructTypeNode {\n                return new StructTypeNode(span, members, name, metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }       from '../../node';\n    import { EnumVariantNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class EnumTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Enum' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public variants     : EnumVariantNode[],\n                public name         : string = 'Anonymous',\n                public metadata     : Record<string, unknown>,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.variants);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): EnumTypeNode {\n                const cloned = new EnumTypeNode(newSpan || this.span, this.variants, this.name, this.metadata);\n                return cloned;\n            }\n\n            toString(): string {\n                return `enum`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, variants: EnumVariantNode[], name: string = 'Anonymous', metadata: Record<string, unknown> = {}): EnumTypeNode {\n                return new EnumTypeNode(span, variants, name, metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class UnionTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Union' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public types        : TypeNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.types);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): UnionTypeNode {\n                const cloned = new UnionTypeNode(newSpan || this.span, this.types);\n                return cloned;\n            }\n\n            toString(): string {\n                return `union`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, types: TypeNode[]): UnionTypeNode {\n                return new UnionTypeNode(span, types);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { IdentNode }        from '../../../ast';\n    import { Span, Node }       from '../../node';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ErrsetTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'errset' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public members      : IdentNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.members);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ErrsetTypeNode {\n                const cloned = new ErrsetTypeNode(newSpan || this.span, this.members);\n                return cloned;\n            }\n\n            toString(): string {\n                return `error`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, members: IdentNode[]): ErrsetTypeNode {\n                return new ErrsetTypeNode(span, members);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ParenTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Paren' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public type         : TypeNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.type];\n            }\n\n            clone(newSpan?: Span): ParenTypeNode {\n                const cloned = new ParenTypeNode(newSpan || this.span, this.type);\n                return cloned;\n            }\n\n            toString(): string {\n                return `paren`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, type: TypeNode): ParenTypeNode {\n                return new ParenTypeNode(span, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { DEF_SPAN, Node, Span }                     from '../node';\n    import { ExprNode }                                 from './ExprNode';\n\n    import { PrimitiveKind, PrimitiveTypeNode }         from '../level-3/TypeNodes/PrimitiveTypeNode';\n    import { OptionalTypeNode }                         from '../level-3/TypeNodes/OptionalTypeNode';\n    import { PointerTypeNode }                          from '../level-3/TypeNodes/PointerTypeNode';\n    import { ArrayTypeNode }                            from '../level-3/TypeNodes/ArrayTypeNode';\n    import { TupleTypeNode }                            from '../level-3/TypeNodes/TupleTypeNode';\n    import { FunctionTypeNode }                         from '../level-3/TypeNodes/FunctionTypeNode';\n    import { StructTypeNode }                           from '../level-3/TypeNodes/StructTypeNode';\n    import { EnumTypeNode }                             from '../level-3/TypeNodes/EnumTypeNode';\n    import { UnionTypeNode }                            from '../level-3/TypeNodes/UnionTypeNode';\n\n    import { IdentNode }                                from '../level-4/CommonNodes/IdentNode';\n\n    import { StructMemberNode }                         from '../level-5/ExprNodes/StructMemberNode';\n    import { EnumVariantNode }                          from '../level-5/ExprNodes/EnumVariantNode';\n    import { ErrsetTypeNode }                           from '../level-3/TypeNodes/ErrsetTypeNode';\nimport { ParenTypeNode } from '../level-3/TypeNodes/ParenTypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type TypeKind =\n        | 'unset'       | 'primitive'   | 'ident'       | 'pointer'\n        | 'array'       | 'tuple'       | 'function'    | 'optional'\n        | 'struct'      | 'enum'        | 'union'       | 'errset'\n        | 'paren';\n\n    export type UnsetSource = null;\n\n    export type TypeTypes =\n    | UnsetSource           | PrimitiveTypeNode | IdentNode         | OptionalTypeNode\n    | PointerTypeNode       | ArrayTypeNode     | TupleTypeNode     | FunctionTypeNode\n    | StructTypeNode        | EnumTypeNode      | UnionTypeNode     | ErrsetTypeNode\n    | ParenTypeNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TypeNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 2;\n\n            constructor(\n                public span         : Span,\n                public kind         : TypeKind,\n                public source       : TypeTypes,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            getChildrenNodes(): Node[] {\n                return this.source ? this.source.getChildrenNodes() : []; }\n\n            clone(newSpan?: Span): TypeNode {\n                return new TypeNode(newSpan ?? this.span, this.kind, this.source); }\n\n            toString(): string {\n                return this.source?.toString() || `Type(${this.kind})`; }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: TypeKind)  { return this.kind === kind; }\n            isPrimitive()       { return this.is('primitive'); }\n            isVoid()            { return this.isPrimitive() && this.getPrimitive()!.isVoid(); }\n            isType()            { return this.isPrimitive() && this.getPrimitive()!.isType(); }\n            isNull()            { return this.isPrimitive() && this.getPrimitive()!.isNull(); }\n            isUndefined()       { return this.isPrimitive() && this.getPrimitive()!.isUndefined(); }\n            isAny()             { return this.isPrimitive() && this.getPrimitive()!.isAny(); }\n            isErr()             { return this.isPrimitive() && this.getPrimitive()!.isErr(); }\n            isSigned()          { return this.isPrimitive() && this.getPrimitive()!.isSigned(); }\n            isUnsigned()        { return this.isPrimitive() && this.getPrimitive()!.isUnsigned(); }\n            isComptimeInt()     { return this.isPrimitive() && this.getPrimitive()!.isComptimeInt(); }\n            isInteger()         { return this.isPrimitive() && this.getPrimitive()!.isInteger(); }\n            isComptimeFloat()   { return this.isPrimitive() && this.getPrimitive()!.isComptimeFloat(); }\n            isFloat()           { return this.isPrimitive() && this.getPrimitive()!.isFloat(); }\n            isNumeric()         { return this.isPrimitive() && this.getPrimitive()!.isNumeric(); }\n            isBool()            { return this.isPrimitive() && this.getPrimitive()!.isBool(); }\n            isIdent()           { return this.is('ident'); }\n\n            isPointer()         { return this.kind === 'pointer'; }\n            isOptional()        { return this.kind === 'optional'; }\n            isArray()           { return this.kind === 'array'; }\n            isU8Array()         { return this.isArray() && this.getArray()!.isU8Array(); }\n            isU16Array()        { return this.isArray() && this.getArray()!.isU16Array(); }\n            isU32Array()        { return this.isArray() && this.getArray()!.isU32Array(); }\n            isTuple()           { return this.kind === 'tuple'; }\n            isFunction()        { return this.kind === 'function'; }\n            isStruct()          { return this.kind === 'struct'; }\n            isErrset()          { return this.kind === 'errset'; }\n            isEnum()            { return this.kind === 'enum'; }\n            isUnion()           { return this.kind === 'union'; }\n            isParen()           { return this.kind === 'paren'; }\n\n            getPrimitive()      : PrimitiveTypeNode | undefined { return this.is('primitive')   ? this.source as PrimitiveTypeNode  : undefined; }\n            getOptional()       : OptionalTypeNode  | undefined { return this.is('optional')    ? this.source as OptionalTypeNode   : undefined; }\n            getPointer()        : PointerTypeNode   | undefined { return this.is('pointer')     ? this.source as PointerTypeNode    : undefined; }\n            getArray()          : ArrayTypeNode     | undefined { return this.is('array')       ? this.source as ArrayTypeNode      : undefined; }\n            getTuple()          : TupleTypeNode     | undefined { return this.is('tuple')       ? this.source as TupleTypeNode      : undefined; }\n            getFunction()       : FunctionTypeNode  | undefined { return this.is('function')    ? this.source as FunctionTypeNode   : undefined; }\n            getStruct()         : StructTypeNode    | undefined { return this.is('struct')      ? this.source as StructTypeNode     : undefined; }\n            getErrset()         : ErrsetTypeNode    | undefined { return this.is('errset')      ? this.source as ErrsetTypeNode      : undefined; }\n            getEnum()           : EnumTypeNode      | undefined { return this.is('enum')        ? this.source as EnumTypeNode       : undefined; }\n            getUnion()          : UnionTypeNode     | undefined { return this.is('union')       ? this.source as UnionTypeNode      : undefined; }\n            getParen()          : ParenTypeNode     | undefined { return this.is('paren')       ? this.source as ParenTypeNode      : undefined; }\n            getIdent()          : IdentNode         | undefined { return this.is('ident')       ? this.source as IdentNode          : undefined; }\n            getWidth()          : number            | undefined { return this.is('primitive')   ? this.getPrimitive()!.width        : undefined; }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static asUnset(span?: Span): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'unset', null);\n            }\n\n            static asPrimitive(span: Span | undefined, kind: PrimitiveKind, text?: string, width?: number): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'primitive', PrimitiveTypeNode.create(kind, span || DEF_SPAN, text, width));\n            }\n\n            static asVoid(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'void');\n            }\n\n            static asBool(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'bool');\n            }\n\n            static asSigned(span: Span | undefined, text: string, width?: number): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'signed', text, width ?? PrimitiveTypeNode.calcWidth('i', text));\n            }\n\n            static asUnsigned(span: Span | undefined, text: string, width?: number): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'unsigned', text, width ?? PrimitiveTypeNode.calcWidth('u', text));\n            }\n\n            static asFloat(span: Span | undefined, text: string, width?: number): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'float', text, width ?? PrimitiveTypeNode.calcWidth('f', text));\n            }\n\n            static asNull(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'null');\n            }\n\n            static asUndefined(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'und');\n            }\n\n            static asAny(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'any');\n            }\n\n            static asErr(span?: Span, text?: string): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'err', text);\n            }\n\n            static asType(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'type');\n            }\n\n            static asComptimeInt(span: Span | undefined, text: string): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'cint', text, 64);\n            }\n\n            static asComptimeFloat(span: Span | undefined, text: string): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'cflt', text, 64);\n            }\n\n            static asIdentifier(span: Span | undefined, name: string): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'ident', IdentNode.create(span || DEF_SPAN, name));\n            }\n\n            static asPointer(span: Span | undefined, target: TypeNode, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'pointer', PointerTypeNode.create(span || DEF_SPAN, target, mutable));\n            }\n\n            static asOptional(span: Span | undefined, target: TypeNode): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'optional', OptionalTypeNode.create(span || DEF_SPAN, target));\n            }\n\n            static asArray(span: Span | undefined, target: TypeNode, size?: ExprNode, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, target, size, mutable));\n            }\n\n            static asU8Array(span: Span | undefined, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, TypeNode.asUnsigned(span, 'u8', 8), undefined, mutable));\n            }\n\n            static asU16Array(span: Span | undefined, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, TypeNode.asUnsigned(span, 'u16', 16), undefined, mutable));\n            }\n\n            static asU32Array(span: Span | undefined, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, TypeNode.asUnsigned(span, 'u32', 32), undefined, mutable));\n            }\n\n            static asTuple(span: Span | undefined, fields: TypeNode[]): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'tuple', TupleTypeNode.create(span || DEF_SPAN, fields));\n            }\n\n            static asFunction(span: Span | undefined, params: TypeNode[], returnType?: TypeNode, errorType?: TypeNode): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'function', FunctionTypeNode.create(span || DEF_SPAN, params, returnType, errorType));\n            }\n\n            static asErrset(span: Span | undefined, members: IdentNode[]): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'errset', ErrsetTypeNode.create(span || DEF_SPAN, members));\n            }\n\n            static asStruct(span: Span | undefined, members: StructMemberNode[], name: string = 'Anonymous'): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'struct', StructTypeNode.create(span || DEF_SPAN, members, name));\n            }\n\n            static asEnum(span: Span | undefined, variants: EnumVariantNode[], name: string = 'Anonymous'): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'enum', EnumTypeNode.create(span || DEF_SPAN, variants, name));\n            }\n\n            static asUnion(span: Span | undefined, types: TypeNode[]): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'union', UnionTypeNode.create(span || DEF_SPAN, types));\n            }\n\n            static asParen(span: Span | undefined, type: TypeNode): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'paren', ParenTypeNode.create(span || DEF_SPAN, type));\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }           from '../../node';\n    import { IdentNode }            from '../../level-4/CommonNodes/IdentNode';\n    import { LiteralNode, LiteralKind, LiteralValue }\n                                    from '../../level-4/ExprNodes/LiteralNode';\n    import { ObjectNode }           from '../../level-4/ExprNodes/ObjectNode';\n    import { PropNode }             from '../../level-5/ExprNodes/PropNode';\n    import { ParenNode }            from '../../level-4/ExprNodes/ParenNode';\n    import { ExprNode }             from '../../level-2/ExprNode';\n    import { ExprTupleNode }        from '../../../ast';\n    import { TypeNode }             from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PrimaryKind = 'Literal' | 'Ident' | 'Paren' | 'Object' | 'Tuple' | 'Type';\n    export type PrimaryTypes = IdentNode | LiteralNode | ParenNode | ObjectNode | ExprTupleNode | TypeNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PrimaryNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PrimaryKind,\n                public span         : Span,\n                public source       ?: PrimaryTypes,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.source!);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PrimaryNode {\n                const cloned = new PrimaryNode(this.kind, newSpan || this.span, this.source);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PrimaryKind): boolean {\n                return this.kind === kind;\n            }\n\n            getLiteral(): LiteralNode {\n                return this.source as LiteralNode;\n            }\n\n            getIdent(): IdentNode {\n                return this.source as IdentNode;\n            }\n\n            getObject(): ObjectNode {\n                return this.source as ObjectNode;\n            }\n\n            getParen(): ParenNode {\n                return this.source as ParenNode;\n            }\n\n            getTuple(): ExprTupleNode {\n                return this.source as ExprTupleNode;\n            }\n\n            getType(): TypeNode {\n                return this.source as TypeNode;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PrimaryKind, span: Span, source?: PrimaryTypes): PrimaryNode {\n                // Validate\n                if(kind === 'Ident' && !(source instanceof IdentNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Literal' && !(source instanceof LiteralNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Object' && !(source instanceof ObjectNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Paren' && !(source instanceof ParenNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Tuple' && !(source instanceof ExprTupleNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Type' && !(source instanceof TypeNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n\n                // Create\n                return new PrimaryNode(kind, span, source);\n            }\n\n            static asIdent(span:Span, name: string, builtin= false) : PrimaryNode {\n                return this.create('Ident', span, IdentNode.create(span, name, builtin));\n            }\n\n            static asLiteral(kind: LiteralKind, span:Span, value: LiteralValue) : PrimaryNode {\n                return this.create('Literal', span, LiteralNode.create(kind, span, value));\n            }\n\n            static asParen(span:Span, source: ExprNode) : PrimaryNode {\n                return this.create('Paren', span, ParenNode.create(span, source));\n            }\n\n            static asObject(span:Span, props: PropNode[], ident: IdentNode | undefined) : PrimaryNode {\n                return this.create('Object', span, ObjectNode.create(span, props, ident));\n            }\n\n            static asTuple(span:Span, exprs: ExprNode[]) : PrimaryNode {\n                return this.create('Tuple', span, ExprTupleNode.create(span, exprs));\n            }\n\n            static asType(span:Span, type: TypeNode) : PrimaryNode {\n                return this.create('Type', span, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class MemberAccessNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'MemberAccess' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public target       : ExprNode,\n                public optional     : boolean\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.base);\n                children.push(this.target);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): MemberAccessNode {\n                const cloned = new MemberAccessNode(newSpan || this.span, this.base, this.target, this.optional);\n                return cloned;\n            }\n\n            toString(): string {\n                return `${this.base.toString()}${this.optional ? '?.' : '.'}${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, base: ExprNode, target: ExprNode, optional= false): MemberAccessNode {\n                return new MemberAccessNode(span, base, target, optional);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ArrayAccessNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'ArrayAccess' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public index        : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.base);\n                children.push(this.index);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ArrayAccessNode {\n                const cloned = new ArrayAccessNode(newSpan || this.span, this.base, this.index);\n                return cloned;\n            }\n\n            toString(): string {\n                return `${this.base.toString()}[${this.index.toString()}]`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, base: ExprNode, index: ExprNode): ArrayAccessNode {\n                return new ArrayAccessNode(span, base, index);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class CallNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Call' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public args         : ExprNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.base);\n                children.push(...this.args);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): CallNode {\n                const cloned = new CallNode(newSpan || this.span, this.base, this.args);\n                return cloned;\n            }\n\n            toString(): string {\n                const argsStr = this.args.map(arg => arg.toString()).join(', ');\n                return `${this.base.toString()}(${argsStr})`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, base: ExprNode, args: ExprNode[]): CallNode {\n                return new CallNode(span, base, args);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }           from '../../node';\n    import { ExprNode }             from '../../level-2/ExprNode';\n    import { MemberAccessNode }     from '../../level-5/ExprNodes/MemberAccessNode';\n    import { ArrayAccessNode }      from '../../level-5/ExprNodes/ArrayAccessNode';\n    import { CallNode }             from '../../level-5/ExprNodes/CallNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PostfixKind =\n    | 'Increment'    | 'Decrement'       | 'Dereference' | 'MemberAccess'\n    | 'Call'         | 'ArrayAccess';\n\n    export type PostfixTypes = ExprNode | MemberAccessNode | ArrayAccessNode | CallNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PostfixNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PostfixKind,\n                public span         : Span,\n                public expr         : PostfixTypes,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PostfixNode {\n                const cloned = new PostfixNode(this.kind, newSpan || this.span, this.expr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PostfixKind): boolean {\n                return this.kind === kind;\n            }\n\n            getCall(): CallNode {\n                return this.expr as CallNode;\n            }\n\n            getMemberAccess(): MemberAccessNode {\n                return this.expr as MemberAccessNode;\n            }\n\n            getArrayAccess(): ArrayAccessNode {\n                return this.expr as ArrayAccessNode;\n            }\n\n            getAsExprNode(): ExprNode | undefined {\n                if(this.is('Increment') || this.is('Decrement') || this.is('Dereference')) {\n                    return this.expr as ExprNode;\n                }\n\n                return undefined;\n            }\n\n            toString(): string {\n                switch (this.kind) {\n                    case 'Increment':    return `${this.expr.toString()}++`;\n                    case 'Decrement':    return `${this.expr.toString()}--`;\n                    case 'Dereference':  return `*${this.expr.toString()}`;\n                    case 'MemberAccess': return this.getMemberAccess().toString();\n                    case 'ArrayAccess':  return this.getArrayAccess().toString();\n                    case 'Call':         return this.getCall().toString();\n                    default:             return `${this.expr.toString()}/* unknown postfix */`;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PostfixKind, span: Span, expr: PostfixTypes): PostfixNode {\n                return new PostfixNode(kind, span, expr);\n            }\n\n            static asIncrement(span: Span, base: ExprNode): PostfixNode {\n                return PostfixNode.create('Increment', span, base);\n            }\n\n            static asDecrement(span: Span, base: ExprNode): PostfixNode {\n                return PostfixNode.create('Decrement', span, base);\n            }\n\n            static asDereference(span: Span, base: ExprNode): PostfixNode {\n                return PostfixNode.create('Dereference', span, base);\n            }\n\n            static asMember(span:Span, base: ExprNode, target: ExprNode, optional= false) : PostfixNode {\n                const memberExpr = MemberAccessNode.create(span, base, target, optional);\n                return PostfixNode.create('MemberAccess', span, memberExpr);\n            }\n\n            static asArrayAccess(span: Span, base: ExprNode, index: ExprNode): PostfixNode {\n                const arrayExpr = ArrayAccessNode.create(span, base, index);\n                const node = PostfixNode.create('ArrayAccess', span, arrayExpr);\n                return node;\n            }\n\n            static asCall(span: Span, base: ExprNode, args: ExprNode[]): PostfixNode {\n                const callExpr = CallNode.create(span, base, args);\n                return PostfixNode.create('Call', span, callExpr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PrefixKind =\n    | 'Increment'    | 'Decrement'       | 'Reference'   | 'UnaryMinus'\n    | 'UnaryPlus'    | 'LogicalNot'      | 'BitwiseNot';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PrefixNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PrefixKind,\n                public span         : Span,\n                public expr         : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PrefixNode {\n                const cloned = new PrefixNode(this.kind, newSpan || this.span, this.expr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PrefixKind): boolean {\n                return this.kind === kind;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PrefixKind, span: Span, expr: ExprNode): PrefixNode {\n                return new PrefixNode(kind, span, expr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type BinaryKind =\n    | 'Unset'         | 'Power'           | 'Additive'    | 'Multiplicative'\n    | 'Shift'         | 'Relational'      | 'Equality'    | 'Bitwise'\n    | 'Logical'       | 'BitwiseAnd'      | 'BitwiseOr'   | 'BitwiseXor'\n    | 'LogicalAnd'    | 'LogicalOr'       | 'Conditional' | 'Assignment';\n\n    const op_table: Record<string, BinaryKind> = {\n        '**': 'Power',\n\n        '*' : 'Multiplicative',\n        '/' : 'Multiplicative',\n        '%' : 'Multiplicative',\n\n        '+' : 'Additive',\n        '-' : 'Additive',\n\n        '<<': 'Shift',\n        '>>': 'Shift',\n\n        '<' : 'Relational',\n        '<=': 'Relational',\n        '>' : 'Relational',\n        '>=': 'Relational',\n\n        '==': 'Equality',\n        '!=': 'Equality',\n\n        '&' : 'BitwiseAnd',\n        '^' : 'BitwiseXor',\n        '|' : 'BitwiseOr',\n\n        'and': 'LogicalAnd',\n        'or' : 'LogicalOr',\n\n        '=' : 'Assignment',\n        '+=': 'Assignment',\n        '-=': 'Assignment',\n        '*=': 'Assignment',\n        '/=': 'Assignment',\n        '%=': 'Assignment'\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class BinaryNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : BinaryKind,\n                public span         : Span,\n                public left         : ExprNode,\n                public operator     : string,\n                public right        : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.left);\n                children.push(this.right);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): BinaryNode {\n                const cloned = new BinaryNode(this.kind, newSpan || this.span, this.left, this.operator, this.right);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: BinaryKind): boolean {\n                return this.kind === kind;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, left: ExprNode, operator: string, right: ExprNode): BinaryNode {\n                const kind : BinaryNode[\"kind\"] = op_table[operator as keyof typeof op_table];\n                if (!kind) {\n                    throw new Error(`Unknown operator: ${operator}`);\n                }\n                return new BinaryNode(kind, span, left, operator, right);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ConditionalNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Conditional' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public condExpr     : ExprNode,\n                public trueExpr     : ExprNode,\n                public falseExpr    : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.condExpr);\n                children.push(this.trueExpr);\n                children.push(this.falseExpr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ConditionalNode {\n                const cloned = new ConditionalNode(newSpan || this.span, this.condExpr, this.trueExpr, this.falseExpr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, condExpr: ExprNode, trueExpr: ExprNode, falseExpr: ExprNode): ConditionalNode {\n                return new ConditionalNode(span, condExpr, trueExpr, falseExpr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n    import { StmtNode }         from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class IfNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'If' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public condExpr     : ExprNode,\n                public thenStmt     : StmtNode,\n                public elseStmt     : StmtNode | null\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.condExpr);\n                children.push(this.thenStmt);\n                if(this.elseStmt) { children.push(this.elseStmt);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): IfNode {\n                const cloned = new IfNode(newSpan || this.span, this.condExpr, this.thenStmt, this.elseStmt);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, condExpr: ExprNode, thenStmt: StmtNode, elseStmt: StmtNode | null): IfNode {\n                return new IfNode(span, condExpr, thenStmt, elseStmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { CaseNode }     from '../../level-5/ExprNodes/CaseNode';\n    import { DefaultNode }  from '../../level-5/ExprNodes/DefaultNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SwitchNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Switch' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public condExpr     : ExprNode,\n                public cases        : CaseNode[],\n                public defCase      : DefaultNode | null\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.condExpr);\n\n                for (const caseItem of this.cases) {\n                    children.push(...caseItem.getChildrenNodes());\n                }\n\n                if (this.defCase) {\n                    children.push(...this.defCase.getChildrenNodes());\n                }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): SwitchNode {\n                const cloned = new SwitchNode(newSpan || this.span, this.condExpr, this.cases, this.defCase);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, condExpr: ExprNode, cases: CaseNode[], defCase: DefaultNode | null): SwitchNode {\n                return new SwitchNode(span, condExpr, cases, defCase);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { StmtNode }         from '../../level-1/StmtNode';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class CatchNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Catch' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public leftExpr     : ExprNode,\n                public tag          : ExprNode | null,\n                public rightStmt    : StmtNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.leftExpr);\n                if(this.tag) { children.push(this.tag);}\n                children.push(this.rightStmt);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): CatchNode {\n                const cloned = new CatchNode(newSpan || this.span, this.leftExpr, this.tag, this.rightStmt);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, leftExpr: ExprNode, tag: ExprNode | null, rightStmt: StmtNode): CatchNode {\n                return new CatchNode(span, leftExpr, tag, rightStmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TryNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Try' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): TryNode {\n                const cloned = new TryNode(newSpan || this.span, this.expr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, leftExpr: ExprNode): TryNode {\n                return new TryNode(span, leftExpr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class RangeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Range' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public leftExpr     : ExprNode | null,\n                public rangeType    : string,\n                public rightExpr    : ExprNode | null\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if(this.leftExpr) { children.push(this.leftExpr);}\n                if(this.rightExpr) { children.push(this.rightExpr);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): RangeNode {\n                const cloned = new RangeNode(newSpan || this.span, this.leftExpr, this.rangeType, this.rightExpr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, leftExpr: ExprNode | null, rangeType: string, elseStmt: ExprNode | null): RangeNode {\n                return new RangeNode(span, leftExpr, rangeType, elseStmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// OrelseNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class OrelseNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'Orelse';\n\n            constructor(\n                public span         : Span,\n                public left         : ExprNode,\n                public right        : ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.left, this.right];\n            }\n\n            clone(newSpan?: Span): OrelseNode {\n                return new OrelseNode(\n                    newSpan ?? this.span,\n                    this.left,\n                    this.right\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, left: ExprNode, right: ExprNode): OrelseNode {\n                return new OrelseNode(span, left, right);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// AsNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class AsNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'As';\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public type         : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.base, this.type];\n            }\n\n            clone(newSpan?: Span): AsNode {\n                return new AsNode(\n                    newSpan ?? this.span,\n                    this.base,\n                    this.type\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, left: ExprNode, type: TypeNode): AsNode {\n                return new AsNode(span, left, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { IdentNode }    from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PropNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Prop' as const;\n            public level = 5;\n\n            constructor(\n                public span        : Span,\n                public key         : IdentNode,\n                public val         : ExprNode | undefined,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if (this.key) {children.push(this.key);}\n                if (this.val) {children.push(this.val);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PropNode {\n                const cloned = new PropNode(newSpan ?? this.span, this.key, this.val);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, key: IdentNode, val: ExprNode): PropNode {\n                return new PropNode(span, key, val);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { StmtNode }         from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class CaseNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Case' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n                public stmt         : StmtNode | null,\n                public hasBreak     : boolean | undefined\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                if(this.stmt) { children.push(this.stmt); }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): CaseNode {\n                const cloned = new CaseNode(newSpan || this.span, this.expr, this.stmt, this.hasBreak);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, expr: ExprNode, stmt: StmtNode | null, hasBreak: boolean | undefined = undefined): CaseNode {\n                return new CaseNode(span, expr, stmt, hasBreak);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { StmtNode }         from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DefaultNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Default' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public stmt         : StmtNode,\n                public hasBreak     : boolean | undefined\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.stmt);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): DefaultNode {\n                const cloned = new DefaultNode(newSpan || this.span, this.stmt, this.hasBreak);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, stmt: StmtNode, hasBreak: boolean | undefined = undefined): DefaultNode {\n                return new DefaultNode(span, stmt, hasBreak);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// TypeofNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TypeofNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'Typeof';\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.expr];\n            }\n\n            clone(newSpan?: Span): TypeofNode {\n                return new TypeofNode(\n                    newSpan ?? this.span,\n                    this.expr\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, expr: ExprNode): TypeofNode {\n                return new TypeofNode(span, expr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// SizeofNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SizeofNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'Sizeof';\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.expr];\n            }\n\n            clone(newSpan?: Span): SizeofNode {\n                return new SizeofNode(\n                    newSpan ?? this.span,\n                    this.expr\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, expr: ExprNode): SizeofNode {\n                return new SizeofNode(span, expr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, DEF_SPAN }                         from '../node';\n    import { StmtNode }                                     from '../level-1/StmtNode';\n    import { TypeNode }                                     from './TypeNode';\n\n    import { PrimaryNode }                                  from '../level-3/ExprNodes/PrimaryNode';\n    import { PostfixNode }                                  from '../level-3/ExprNodes/PostfixNode';\n    import { PrefixNode }                                   from '../level-3/ExprNodes/PrefixNode';\n    import { BinaryNode }                                   from '../level-3/ExprNodes/BinaryNode';\n    import { ConditionalNode as CondNode }                  from '../level-3/ExprNodes/ConditionalNode';\n    import { IfNode }                                       from '../level-3/ExprNodes/IfNode';\n    import { SwitchNode }                                   from '../level-3/ExprNodes/SwitchNode';\n    import { CatchNode }                                    from '../level-3/ExprNodes/CatchNode';\n    import { TryNode }                                      from '../level-3/ExprNodes/TryNode';\n    import { RangeNode }                                    from '../level-3/ExprNodes/RangeNode';\n    import { OrelseNode }                                   from '../level-3/ExprNodes/OrelseNode';\n    import { AsNode }                                       from '../level-3/ExprNodes/AsNode';\n\n    import { LiteralNode }                                  from '../level-4/ExprNodes/LiteralNode';\n    import { IdentNode }                                    from '../level-4/CommonNodes/IdentNode';\n    import { ParenNode }                                    from '../level-4/ExprNodes/ParenNode';\n    import { ObjectNode }                                   from '../level-4/ExprNodes/ObjectNode';\n    import { ExprTupleNode }                                from '../level-4/ExprNodes/ExprTupleNode';\n\n    import { PropNode }                                     from '../level-5/ExprNodes/PropNode';\n    import { CaseNode }                                     from '../level-5/ExprNodes/CaseNode';\n    import { DefaultNode }                                  from '../level-5/ExprNodes/DefaultNode';\n    import { TypeofNode }                                   from '../level-3/ExprNodes/TypeofNode';\n    import { SizeofNode }                                   from '../level-3/ExprNodes/SizeofNode';\n\n    export { PropNode, CaseNode, DefaultNode };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type ExprKind =\n    | 'Unset'       | 'Primary'     | 'Postfix'     | 'Prefix'\n    | 'Binary'      | 'Cond'        | 'If'          | 'Switch'\n    | 'Catch'       | 'Try'         | 'Range'       | 'Orelse'\n    | 'As'          | 'Typeof'      | 'Sizeof';\n\n    export type ExprTypes =\n    | PrimaryNode   | PostfixNode   | PrefixNode    | BinaryNode\n    | CondNode      | IfNode        | SwitchNode    | CatchNode\n    | TryNode       | RangeNode     | OrelseNode    | AsNode\n    | TypeofNode    | SizeofNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ExprNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 2;\n\n            constructor(\n                public kind : ExprKind,\n                public span : Span,\n                public data : ExprTypes,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.data.getChildrenNodes();\n            }\n\n            clone(newSpan?: Span): ExprNode {\n                const cloned = new ExprNode(this.kind, newSpan ?? this.span, this.data);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            getPrimary()        : PrimaryNode   | undefined     { return this.is('Primary')     ? this.data as PrimaryNode      : undefined; }\n            getPostfix()        : PostfixNode   | undefined     { return this.is('Postfix')     ? this.data as PostfixNode      : undefined; }\n            getPrefix()         : PrefixNode    | undefined     { return this.is('Prefix')      ? this.data as PrefixNode       : undefined; }\n            getBinary()         : BinaryNode    | undefined     { return this.is('Binary')      ? this.data as BinaryNode       : undefined; }\n            getConditional()    : CondNode      | undefined     { return this.is('Cond')        ? this.data as CondNode         : undefined; }\n            getIf()             : IfNode        | undefined     { return this.is('If')          ? this.data as IfNode           : undefined; }\n            getSwitch()         : SwitchNode    | undefined     { return this.is('Switch')      ? this.data as SwitchNode       : undefined; }\n            getCatch()          : CatchNode     | undefined     { return this.is('Catch')       ? this.data as CatchNode        : undefined; }\n            getTry()            : TryNode       | undefined     { return this.is('Try')         ? this.data as TryNode          : undefined; }\n            getRange()          : RangeNode     | undefined     { return this.is('Range')       ? this.data as RangeNode        : undefined; }\n            getOrelse()         : OrelseNode    | undefined     { return this.is('Orelse')      ? this.data as OrelseNode       : undefined; }\n            getAs()             : AsNode        | undefined     { return this.is('As')          ? this.data as AsNode           : undefined; }\n\n            getTypeof()         : TypeofNode    | undefined     { return this.is('Typeof')      ? this.data as TypeofNode      : undefined; }\n            getSizeof()         : SizeofNode    | undefined     { return this.is('Sizeof')      ? this.data as SizeofNode      : undefined; }\n\n            getLiteral()        : LiteralNode   | undefined     { return this.is('Primary') && this.getPrimary()!.is('Literal') ? this.getPrimary()!.getLiteral() : undefined; }\n            getIdent()          : IdentNode     | undefined     { return this.is('Primary') && this.getPrimary()!.is('Ident')   ? this.getPrimary()!.getIdent()   : undefined; }\n            getParen()          : ParenNode     | undefined     { return this.is('Primary') && this.getPrimary()!.is('Paren')   ? this.getPrimary()!.getParen()   : undefined; }\n            getObject()         : ObjectNode    | undefined     { return this.is('Primary') && this.getPrimary()!.is('Object')  ? this.getPrimary()!.getObject()  : undefined; }\n            getTuple()          : ExprTupleNode | undefined     { return this.is('Primary') && this.getPrimary()!.is('Tuple')   ? this.getPrimary()!.getTuple()   : undefined; }\n            getType()           : TypeNode      | undefined     { return this.is('Primary') && this.getPrimary()!.is('Type')    ? this.getPrimary()!.getType()    : undefined; }\n\n            is(kind: ExprKind)  { return this.kind === kind; }\n            isOrEndWith(kind: ExprKind) : boolean { return (this.is(kind) || this.isParen() && this.getParen()!.source.isOrEndWith(kind)) || false; }\n\n            isIdent()           { return this.is('Primary') && this.getPrimary()!.is('Ident'); }\n            isLiteral()         { return this.is('Primary') && this.getPrimary()!.is('Literal'); }\n            isObject()          { return this.is('Primary') && this.getPrimary()!.is('Object'); }\n            isParen()           { return this.is('Primary') && this.getPrimary()!.is('Paren'); }\n            isTuple()           { return this.is('Primary') && this.getPrimary()!.is('Tuple'); }\n            isType()            { return this.is('Primary') && this.getPrimary()!.is('Type'); }\n\n            isMemberAccess()    { return this.is('Postfix') && this.getPostfix()!.is('MemberAccess'); }\n            isArrayAccess()     { return this.is('Postfix') && this.getPostfix()!.is('ArrayAccess'); }\n            isCall()            { return this.is('Postfix') && this.getPostfix()!.is('Call'); }\n            isOrelse()          { return this.is('Orelse'); }\n            isAs()              { return this.is('As'); }\n\n            isTypeof()          { return this.is('Typeof'); }\n            isSizeof()          { return this.is('Sizeof'); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            // ────────────────────────── Primary ──────────────────────────\n\n                static asPrimary(span: Span, source: PrimaryNode) : ExprNode {\n                    return new ExprNode('Primary', span, source); }\n\n                static asLiteral(span: Span, kind: LiteralNode[\"kind\"], value: LiteralNode[\"value\"]) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asLiteral(kind, span, value)); }\n\n                static asIdent(span: Span, name: string, builtin = false) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asIdent(span || DEF_SPAN, name, builtin)); }\n\n                static asType(span: Span, type: TypeNode) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asType(span || DEF_SPAN, type)); }\n\n                static asInteger(span: Span, value: number) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Integer', value); }\n\n                static asFloat(span: Span, value: number) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Float', value); }\n\n                static asBool(span: Span, value: boolean) : ExprNode  { return this.asLiteral(span || DEF_SPAN, 'Bool', value); }\n\n                static asNull(span: Span) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Null', null); }\n\n                static asUndefined(span: Span) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Undefined', undefined); }\n\n                static asString(span: Span, value: string) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'String', value); }\n\n                static asChar(span: Span, value: string) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Character', value); }\n\n                static asArray(span: Span, elements: ExprNode[]) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Array', [...elements]); }\n\n                static asObject(span: Span, props: PropNode[], ident?: IdentNode | undefined) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asObject(span || DEF_SPAN, props, ident)); }\n\n                static asParen(span:Span, expression: ExprNode) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asParen(span || DEF_SPAN, expression)); }\n\n                static asTuple(span:Span, fields: ExprNode[]) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asTuple(span || DEF_SPAN, fields)); }\n\n            // ────────────────────────── Postfix ──────────────────────────\n\n                static asPostfix(span: Span, source: PostfixNode) : ExprNode {\n                    return new ExprNode('Postfix', span, source); }\n\n                static asPostIncrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asIncrement(span || DEF_SPAN, base)); }\n\n                static asPostDecrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asDecrement(span || DEF_SPAN, base)); }\n\n                static asDereference(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asDereference(span || DEF_SPAN, base)); }\n\n                static asMemberAccess(span: Span, base: ExprNode, target: ExprNode, optional = false) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asMember(span || DEF_SPAN, base, target, optional)); }\n\n                static asCall(span: Span, base: ExprNode, args: ExprNode[]) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asCall(span || DEF_SPAN, base, args)); }\n\n                static asArrayAccess(span: Span, base: ExprNode, index: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asArrayAccess(span || DEF_SPAN, base, index)); }\n\n            // ────────────────────────── Prefix ──────────────────────────\n\n                static asPrefix(span: Span, source: PrefixNode) : ExprNode {\n                    return new ExprNode('Prefix', span, source); }\n\n                static asPreIncrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('Increment', span, base)); }\n\n                static asPreDecrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('Decrement', span, base)); }\n\n                static asReference(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('Reference', span, base)); }\n\n                static asUnaryMinus(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('UnaryMinus', span, base)); }\n\n                static asUnaryPlus(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('UnaryPlus', span, base)); }\n\n                static asLogicalNot(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('LogicalNot', span, base)); }\n\n                static asxBitwiseNot(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('BitwiseNot', span, base)); }\n\n            // ────────────────────────── Rest ──────────────────────────\n\n                static asBinary(span:Span, left: ExprNode, operator: string, right: ExprNode) : ExprNode {\n                    return new ExprNode('Binary', span, BinaryNode.create(span || DEF_SPAN, left, operator, right)); }\n\n                static asConditional(span: Span, condExpr: ExprNode, trueExpr: ExprNode, falseExpr: ExprNode) : ExprNode {\n                    return new ExprNode('Cond', span, CondNode.create(span || DEF_SPAN, condExpr, trueExpr, falseExpr)); }\n\n                static asIf(span: Span, condExpr: ExprNode, thenStmt: StmtNode, elseStmt: StmtNode | null) : ExprNode {\n                    return new ExprNode('If', span, IfNode.create(span || DEF_SPAN, condExpr, thenStmt, elseStmt)); }\n\n                static asSwitch(span: Span, condExpr: ExprNode, cases: CaseNode[], defCase: DefaultNode | null) : ExprNode {\n                    return new ExprNode('Switch', span, SwitchNode.create(span || DEF_SPAN, condExpr, cases, defCase)); }\n\n                static asCatch(span: Span, leftExpr: ExprNode, tag: ExprNode | null, rightStmt: StmtNode) : ExprNode {\n                    return new ExprNode('Catch', span, CatchNode.create(span || DEF_SPAN, leftExpr, tag, rightStmt)); }\n\n                static asTry(span: Span, expr: ExprNode) : ExprNode {\n                    return new ExprNode('Try', span, TryNode.create(span || DEF_SPAN, expr)); }\n\n                static asRange(span: Span, leftExpr: ExprNode | null, rangeType: string, rightExpr: ExprNode | null) : ExprNode {\n                    return new ExprNode('Range', span, RangeNode.create(span || DEF_SPAN, leftExpr, rangeType, rightExpr)); }\n\n                static asOrelse(span: Span, left: ExprNode, right: ExprNode) : ExprNode {\n                    return new ExprNode('Orelse', span, OrelseNode.create(span || DEF_SPAN, left, right)); }\n\n                static asAs(span: Span, base: ExprNode, type: TypeNode) : ExprNode {\n                    return new ExprNode('As', span, AsNode.create(span || DEF_SPAN, base, type)); }\n\n                static asTypeof(span: Span, type: ExprNode) : ExprNode {\n                    return new ExprNode('Typeof', span, TypeofNode.create(span || DEF_SPAN, type)); }\n\n                static asSizeof(span: Span, type: ExprNode) : ExprNode {\n                    return new ExprNode('Sizeof', span, SizeofNode.create(span || DEF_SPAN, type)); }\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ExprTupleNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Tuple' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public fields       : ExprNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.fields);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ExprTupleNode {\n                const cloned = new ExprTupleNode(newSpan || this.span, this.fields);\n                return cloned;\n            }\n\n            toString(): string {\n                return `{ ${this.fields.map(f => `f${f.getIdent()!.name}`).join(', ') } }`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, fields: ExprNode[]): ExprTupleNode {\n                return new ExprTupleNode(span, fields);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// EnumVariantNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { TypeNode } from '../../level-2/TypeNode';\nimport { IdentNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class EnumVariantNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'EnumVariant' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public ident        : IdentNode,\n                public type?        : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.type ? [this.type] : [];\n            }\n\n            clone(newSpan?: Span): EnumVariantNode {\n                return new EnumVariantNode(\n                    newSpan ?? this.span,\n                    this.ident,\n                    this.type\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            hasType(): boolean {\n                return this.type !== undefined;\n            }\n\n            isUnit(): boolean {\n                return this.type === undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, ident: IdentNode, type?: TypeNode): EnumVariantNode {\n                return new EnumVariantNode(span, ident, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// FieldNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityKind, VisibilityInfo, MutabilityInfo, ComptimeInfo }\n                                        from '../../node';\n    import { ExprNode }                 from '../../level-2/ExprNode';\n    import { TypeNode }                 from '../../level-2/TypeNode';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class FieldNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 5;\n            public kind = 'Field' as const;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public comptime         : ComptimeInfo,\n                public mutability       : MutabilityInfo,\n                public ident            : IdentNode,\n                public type?            : TypeNode,\n                public initializer      ?: ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if (this.type)          { children.push(this.type); }\n                if (this.initializer)   { children.push(this.initializer); }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): FieldNode {\n                return new FieldNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.comptime,\n                    this.mutability,\n                    this.ident,\n                    this.type,\n                    this.initializer\n                );\n            }\n\n            // for factory\n            getField(): FieldNode {\n                return this;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, mutability: MutabilityInfo, ident: IdentNode, type?: TypeNode, initializer?: ExprNode): FieldNode {\n                return new FieldNode(span, visibility, comptime, mutability, ident, type, initializer);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// StructMemberNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { FieldNode, FuncStmtNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type StructMemberKind = 'Field' | 'Method';\n\n    export type StructMemberVisibility = 'Private' | 'Public' | 'Static';\n\n    export type StructMemeberSourceType = FuncStmtNode | FieldNode\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class StructMemberNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public kind         : StructMemberKind,\n                public source       : StructMemeberSourceType\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n                if (this.source) children.push(this.source);\n                return children;\n            }\n\n            clone(newSpan?: Span): StructMemberNode {\n                return new StructMemberNode(\n                    newSpan ?? this.span,\n                    this.kind,\n                    this.source,\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            isField(): boolean {\n                return this.kind === 'Field';\n            }\n\n            isMethod(): boolean {\n                return this.kind === 'Method';\n            }\n\n            getField(): FieldNode | undefined {\n                if(this.isField()) return this.source as FieldNode;\n                return undefined;\n            }\n\n            getMethod(): FuncStmtNode | undefined {\n                if(this.isMethod()) return this.source as FuncStmtNode;\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, source: StructMemeberSourceType): StructMemberNode {\n                return new StructMemberNode(span, source.kind === 'Function' ? 'Method' : 'Field', source);\n            }\n\n            static createField(span: Span, structFieldNode: FieldNode): StructMemberNode {\n                return new StructMemberNode(span, 'Field', structFieldNode);\n            }\n\n            static createMethod(span: Span, funcNode: FuncStmtNode): StructMemberNode {\n                return new StructMemberNode(span, 'Method', funcNode);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":"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","names":[]}